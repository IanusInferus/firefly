<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><base href="."/><style type="text/css">
	@page { size: 21.59cm 27.94cm; margin-top: 2.54cm; margin-bottom: 2.54cm; margin-left: 3.175cm; margin-right: 3.175cm }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	li span.odfLiEnd { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	* { margin:0; }
	.P1 { font-size:10pt; font-family:宋体; }
	.P2 { font-size:12pt; font-family:宋体; }
	.P3 { font-size:10pt; font-family:宋体; color:#008000; }
	.P4 { font-size:10pt; font-family:宋体; color:#2b91af; }
	.P5 { font-size:10pt; font-family:宋体; }
	.T1 { color:#0000ff; font-size:10pt; }
	.T2 { font-size:10pt; }
	.T3 { color:#2b91af; font-size:10pt; }
	.T4 { color:#a31515; font-size:10pt; }
	.T5 { color:#ff0000; font-size:10pt; }
	.T6 { color:#008000; font-size:10pt; }
	.T7 { color:#6464b9; font-size:10pt; }
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:21.59cm;margin-top:2.54cm; margin-bottom:2.54cm; margin-left:3.175cm; margin-right:3.175cm; border-style:none; padding:0cm; "><p class="P5">使用代码生成建立可扩展序列化器(上)</p><p class="P1">地狱门神</p><p class="P1"> </p><p class="P1">在很多程序中，配置文件和用户数据的保存和读取都是一个需要考虑的问题。</p><p class="P1">在以前，用户数据经常保存在INI文件中，后来出现了注册表，于是也有保存在注册表中的。</p><p class="P1">注册表不是一种稳定的方式，不便于用户管理。</p><p class="P1">INI和注册表都难以保存复杂结构的对象，需要手写很多代码。</p><p class="P1"> </p><p class="P1">随着XML和.Net的兴起，越来越多的程序使用XML文件来保存用户数据。</p><p class="P1">不过.Net的内置序列化器System.Xml.Serialization.XmlSerializer是在.Net 2.0之前推出的，对泛型的支持有限。</p><p class="P1">同时，由于其使用特性来标记数据模型中的类和变量，并需要对象实现IXmlSerializable。这是对数据模型的严重污染，非常不利于程序维护。</p><p class="P1"> </p><p class="P1">此外，出于性能的考虑，在数据达到一定规模之后，我们必须使用二进制序列化，以加快加载速度。</p><p class="P1">对于二进制序列化，有很多实现，而且一般都互不兼容。</p><p class="P1">由于很多二进制格式是已经事先确定的，要实现对这些二进制格式的反序列化和序列化支持，是非常困难的，没有很好的工具解决这个问题，经常需要手工维护读文件和写文件两部分代码。</p><p class="P1">.Net的默认实现使得类必须实现ISerializable。这和XML序列化的问题是一样的。</p><p class="P1"> </p><p class="P1">这两种序列化器均难以方便的实现定制功能。</p><p class="P1"> </p><p class="P1">由于这些问题，我建立了两个全新的可扩展序列化器，并使用相同的基础结构。</p><p class="P1">设计目标是：</p><p class="P1">1)可扩展性，二进制序列化应可扩展支持任意二进制格式；</p><p class="P1">2)性能，不能太慢，对于多次序列化、反序列化，每次不应有较大的性能损失；</p><p class="P1">3)无污染，不应对模型数据进行任何插入式的标记；</p><p class="P1">4)可加的版本支持，这一部分应通过可扩展性来实现；</p><p class="P1">5)自动支持泛型集合，特别是List(T)和Dictionary(TKey, TValue)。</p><p class="P1">6)自动支持不变类型，即只读的公开属性和构造函数参数匹配的类型，例如KeyValuePair(TKey, TValue)。</p><p class="P1"> </p><p class="P1">.Net对于泛型的支持不够完整，缺乏泛型λ表达式、泛型委托等语法元素，泛型约束也有很大的限制。</p><p class="P1">因此，代码生成是唯一的强类型的选择。另一个选择是使用弱类型进行动态绑定，不过感觉性能和类型安全都不能保证，所以不用。</p><p class="P1"> </p><p class="P1">先上代码。C#的代码请参见附件。</p><p class="P1"> </p><p class="P1">数据模型如下：</p><p class="P1"> </p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">DataEntry</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Name </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Data </span><span class="T1">As</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">()</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"> </p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">ImmutableDataEntry</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> T)</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">ReadOnly</span><span class="T2"> </span><span class="T1">Property</span><span class="T2"> Name </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span></p><p class="P2"><span class="T2">        </span><span class="T1">Get</span></p><p class="P2"><span class="T2">            </span><span class="T1">Return</span><span class="T2"> NameValue</span></p><p class="P2"><span class="T2">        </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Get</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Property</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">ReadOnly</span><span class="T2"> </span><span class="T1">Property</span><span class="T2"> Data </span><span class="T1">As</span><span class="T2"> </span><span class="T3">T</span></p><p class="P2"><span class="T2">        </span><span class="T1">Get</span></p><p class="P2"><span class="T2">            </span><span class="T1">Return</span><span class="T2"> DataValue</span></p><p class="P2"><span class="T2">        </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Get</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Property</span></p><p class="P1"> </p><p class="P2"><span class="T2">    </span><span class="T1">Private</span><span class="T2"> NameValue </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span></p><p class="P2"><span class="T2">    </span><span class="T1">Private</span><span class="T2"> DataValue </span><span class="T1">As</span><span class="T2"> </span><span class="T3">T</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">Sub</span><span class="T2"> </span><span class="T1">New</span><span class="T2">(</span><span class="T1">ByVal</span><span class="T2"> Name </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span><span class="T2">, </span><span class="T1">ByVal</span><span class="T2"> Data </span><span class="T1">As</span><span class="T2"> </span><span class="T3">T</span><span class="T2">)</span></p><p class="P2"><span class="T2">        </span><span class="T1">Me</span><span class="T2">.NameValue = Name</span></p><p class="P2"><span class="T2">        </span><span class="T1">Me</span><span class="T2">.DataValue = Data</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Sub</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"> </p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">DataObject</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> DataEntries </span><span class="T1">As</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> </span><span class="T3">Dictionary</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">String</span><span class="T2">, </span><span class="T3">DataEntry</span><span class="T2">)</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> ImmutableDataEntries </span><span class="T1">As</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> </span><span class="T3">Dictionary</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">String</span><span class="T2">, </span><span class="T3">ImmutableDataEntry</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">()))</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"> </p><p class="P1">XML序列化代码如下：</p><p class="P1"> </p><p class="P3">'创建自定义XML序列化器实例</p><p class="P2"><span class="T1">Dim</span><span class="T2"> mxs </span><span class="T1">As</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> Firefly.Mapping.</span><span class="T3">XmlSerializer</span></p><p class="P4"> </p><p class="P3">'创建数据</p><p class="P2"><span class="T1">Dim</span><span class="T2"> Obj </span><span class="T1">As</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> </span><span class="T3">DataObject</span></p><p class="P2"><span class="T2">Obj.DataEntries.Add(</span><span class="T4">"DataEntry1"</span><span class="T2">, </span><span class="T1">New</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2"> </span><span class="T1">With</span><span class="T2"> {.Name = </span><span class="T4">"DataEntry1"</span><span class="T2">, .Data = </span><span class="T1">New</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">() {1, 2, 3, 4, 5}})</span></p><p class="P2"><span class="T2">Obj.DataEntries.Add(</span><span class="T4">"DataEntry2"</span><span class="T2">, </span><span class="T1">New</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2"> </span><span class="T1">With</span><span class="T2"> {.Name = </span><span class="T4">"DataEntry2"</span><span class="T2">, .Data = </span><span class="T1">New</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">() {6, 7, 8, 9, 10}})</span></p><p class="P2"><span class="T2">Obj.ImmutableDataEntries.Add(</span><span class="T4">"ImmutableDataEntry1"</span><span class="T2">, </span><span class="T1">New</span><span class="T2"> </span><span class="T3">ImmutableDataEntry</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">())(</span><span class="T4">"ImmutableDataEntry1"</span><span class="T2">, </span><span class="T1">New</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">() {1, 2, 3, 4, 5}))</span></p><p class="P2"><span class="T2">Obj.ImmutableDataEntries.Add(</span><span class="T4">"ImmutableDataEntry2"</span><span class="T2">, </span><span class="T1">New</span><span class="T2"> </span><span class="T3">ImmutableDataEntry</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">())(</span><span class="T4">"ImmutableDataEntry2"</span><span class="T2">, </span><span class="T1">New</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">() {6, 7, 8, 9, 10}))</span></p><p class="P1"> </p><p class="P3">'XML序列化</p><p class="P2"><span class="T1">Dim</span><span class="T2"> Element = mxs.Write(Obj)</span></p><p class="P1"> </p><p class="P3">'XML反序列化</p><p class="P2"><span class="T1">Dim</span><span class="T2"> RoundTripped = mxs.Read(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataObject</span><span class="T2">)(Element)</span></p><p class="P1"> </p><p class="P3">'输出到命令行</p><p class="P2"><span class="T1">Dim</span><span class="T2"> Setting = </span><span class="T1">New</span><span class="T2"> </span><span class="T3">XmlWriterSettings</span><span class="T2"> </span><span class="T1">With</span><span class="T2"> {.Encoding = </span><span class="T3">Console</span><span class="T2">.Out.Encoding, .Indent = </span><span class="T1">True</span><span class="T2">, .OmitXmlDeclaration = </span><span class="T1">False</span><span class="T2">}</span></p><p class="P2"><span class="T1">Using</span><span class="T2"> w = </span><span class="T3">XmlWriter</span><span class="T2">.Create(</span><span class="T3">Console</span><span class="T2">.Out, Setting)</span></p><p class="P1">    Element.Save(w)</p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Using</span></p><p class="P1"> </p><p class="P1">这样就自动生成以下XML文本：</p><p class="P1"> </p><p class="P2"><span class="T1">&lt;?</span><span class="T4">xml</span><span class="T1"> </span><span class="T5">version</span><span class="T1">=</span><span class="T2">"</span><span class="T1">1.0</span><span class="T2">"</span><span class="T1"> </span><span class="T5">encoding</span><span class="T1">=</span><span class="T2">"</span><span class="T1">gb2312</span><span class="T2">"</span><span class="T1">?&gt;</span></p><p class="P2"><span class="T1">&lt;</span><span class="T4">DataObject</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;</span><span class="T4">DataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">DataEntry1</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">DataEntry1</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">1</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">2</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">3</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">4</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">5</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">DataEntry2</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">DataEntry2</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">6</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">7</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">8</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">9</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">10</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;/</span><span class="T4">DataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;</span><span class="T4">ImmutableDataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry1</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry1</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">1</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">2</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">3</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">4</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">5</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry2</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry2</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">6</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">7</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">8</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">9</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">          &lt;</span><span class="T4">Byte</span><span class="T1">&gt;</span><span class="T2">10</span><span class="T1">&lt;/</span><span class="T4">Byte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;/</span><span class="T4">ImmutableDataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">&lt;/</span><span class="T4">DataObject</span><span class="T1">&gt;</span></p><p class="P1"> </p><p class="P1">这个文件中，字节数组使用了默认的集合表示，不利于查看和修改，我们可以使用扩展机制来处理这个问题。</p><p class="P1">两个序列化器均提供三种扩展机制：</p><p class="P1">1) PutReader|PutWriter，用于提供直接的读写替代，直接操作需要读写的对象和数据流|数据树；</p><p class="P1">2) PutReaderTranslator|PutWriterTranslator，提供更高层的抽象，用于将需要读写的对象替代成另一种对象，交给序列化器做后续处理；</p><p class="P1">3) (ReaderResolver|WriterResolver).(ProjectorResolvers|AggregatorResolvers)，提供直接的类型解析替代，但此机制中类型均为运行时类型，编写代码较麻烦。</p><p class="P1">详细的说明将在后面介绍，这里我们使用2)，即对象替代。</p><p class="P1"> </p><p class="P1">声明对象替代器：</p><p class="P1"> </p><p class="P3">'用于将字节数组转换为字符串处理</p><p class="P2"><span class="T1">Private</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">ByteArrayCodec</span></p><p class="P2"><span class="T2">    </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorRangeTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">(), </span><span class="T1">String</span><span class="T2">) </span><span class="T6">'Reader</span></p><p class="P2"><span class="T2">    </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorDomainTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">(), </span><span class="T1">String</span><span class="T2">) </span><span class="T6">'Writer</span></p><p class="P1"> </p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">Function</span><span class="T2"> TranslateProjectorToProjectorRange(</span><span class="T1">Of</span><span class="T2"> D)(</span><span class="T1">ByVal</span><span class="T2"> Projector </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">D</span><span class="T2">, </span><span class="T1">String</span><span class="T2">)) </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">D</span><span class="T2">, </span><span class="T1">Byte</span><span class="T2">()) </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorRangeTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">(), </span><span class="T1">String</span><span class="T2">).TranslateProjectorToProjectorRange</span></p><p class="P2"><span class="T2">        </span><span class="T1">Return</span><span class="T2"> </span><span class="T1">Function</span><span class="T2">(k) </span><span class="T3">Regex</span><span class="T2">.Split(Projector(k).Trim(</span><span class="T4">" \t\r\n"</span><span class="T2">.Descape.ToCharArray), </span><span class="T4">"( |\t|\r|\n)+"</span><span class="T2">, </span><span class="T3">RegexOptions</span><span class="T2">.ExplicitCapture).Select(</span><span class="T1">Function</span><span class="T2">(s) </span><span class="T1">Byte</span><span class="T2">.Parse(s, Globalization.</span><span class="T3">NumberStyles</span><span class="T2">.HexNumber)).ToArray</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Function</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">Function</span><span class="T2"> TranslateProjectorToProjectorDomain(</span><span class="T1">Of</span><span class="T2"> R)(</span><span class="T1">ByVal</span><span class="T2"> Projector </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">String</span><span class="T2">, </span><span class="T3">R</span><span class="T2">)) </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">(), </span><span class="T3">R</span><span class="T2">) </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorDomainTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">(), </span><span class="T1">String</span><span class="T2">).TranslateProjectorToProjectorDomain</span></p><p class="P2"><span class="T2">        </span><span class="T1">Return</span><span class="T2"> </span><span class="T1">Function</span><span class="T2">(ba) Projector(</span><span class="T1">String</span><span class="T2">.Join(</span><span class="T4">" "</span><span class="T2">, (ba.Select(</span><span class="T1">Function</span><span class="T2">(b) b.ToString(</span><span class="T4">"X2"</span><span class="T2">)).ToArray)))</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Function</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"/><p class="P1">将对象替代器注册到序列化器：</p><p class="P1"> </p><p class="P2"><span class="T1">Dim</span><span class="T2"> mxs </span><span class="T1">As</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> Firefly.Mapping.</span><span class="T3">XmlSerializer</span></p><p class="P2"><span class="T2">mxs.PutReaderTranslator(</span><span class="T1">New</span><span class="T2"> </span><span class="T3">ByteArrayCodec</span><span class="T2">)</span></p><p class="P2"><span class="T2">mxs.PutWriterTranslator(</span><span class="T1">New</span><span class="T2"> </span><span class="T3">ByteArrayCodec</span><span class="T2">)</span></p><p class="P1"> </p><p class="P1">这样就自动生成以下XML文本：</p><p class="P1"> </p><p class="P2"><span class="T1">&lt;?</span><span class="T4">xml</span><span class="T1"> </span><span class="T5">version</span><span class="T1">=</span><span class="T2">"</span><span class="T1">1.0</span><span class="T2">"</span><span class="T1"> </span><span class="T5">encoding</span><span class="T1">=</span><span class="T2">"</span><span class="T1">gb2312</span><span class="T2">"</span><span class="T1">?&gt;</span></p><p class="P2"><span class="T1">&lt;</span><span class="T4">DataObject</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;</span><span class="T4">DataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">DataEntry1</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">DataEntry1</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span><span class="T2">01 02 03 04 05</span><span class="T1">&lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">DataEntry2</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">DataEntry2</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span><span class="T2">06 07 08 09 0A</span><span class="T1">&lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndDataEntry</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;/</span><span class="T4">DataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;</span><span class="T4">ImmutableDataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry1</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry1</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span><span class="T2">01 02 03 04 05</span><span class="T1">&lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Key</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry2</span><span class="T1">&lt;/</span><span class="T4">Key</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Name</span><span class="T1">&gt;</span><span class="T2">ImmutableDataEntry2</span><span class="T1">&lt;/</span><span class="T4">Name</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">        &lt;</span><span class="T4">Data</span><span class="T1">&gt;</span><span class="T2">06 07 08 09 0A</span><span class="T1">&lt;/</span><span class="T4">Data</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">      &lt;/</span><span class="T4">Value</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">    &lt;/</span><span class="T4">KeyValuePairOfStringAndImmutableDataEntryOfArrayOfByte</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">  &lt;/</span><span class="T4">ImmutableDataEntries</span><span class="T1">&gt;</span></p><p class="P2"><span class="T1">&lt;/</span><span class="T4">DataObject</span><span class="T1">&gt;</span></p><p class="P1"> </p><p class="P1">这里解释一下ByteArrayCodec的作用。</p><p class="P1">ByteArrayCodec是一个转换字节数组到字符串，并转换回来的类，实现了两个接口：</p><p class="P1"> </p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Interface</span><span class="T2"> </span><span class="T3">IProjectorToProjectorRangeTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> R, M)</span></p><p class="P2"><span class="T2">    </span><span class="T1">Function</span><span class="T2"> TranslateProjectorToProjectorRange(</span><span class="T1">Of</span><span class="T2"> D)(</span><span class="T1">ByVal</span><span class="T2"> Projector </span><span class="T1">As</span><span class="T2"> Func(</span><span class="T1">Of</span><span class="T2"> D, </span><span class="T3">M</span><span class="T2">)) </span><span class="T1">As</span><span class="T2"> Func(</span><span class="T1">Of</span><span class="T2"> D, </span><span class="T3">R</span><span class="T2">)</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Interface</span></p><p class="P1"> </p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Interface</span><span class="T2"> </span><span class="T3">IProjectorToProjectorDomainTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> D, M)</span></p><p class="P2"><span class="T2">    </span><span class="T1">Function</span><span class="T2"> TranslateProjectorToProjectorDomain(</span><span class="T1">Of</span><span class="T2"> R)(</span><span class="T1">ByVal</span><span class="T2"> Projector </span><span class="T1">As</span><span class="T2"> Func(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">M</span><span class="T2">, R)) </span><span class="T1">As</span><span class="T2"> Func(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">D</span><span class="T2">, R)</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Interface</span></p><p class="P1"> </p><p class="P1">这两个接口，其实是用来约束两个泛型高阶函数。D是输入类型，M是中间类型，R是输出类型。</p><p class="P1">所谓的Projector，是指投影函数，即一个将原来的对象转换为具有相同信息或者更少信息的对象的函数。</p><p class="P1">与其相对的，我还定义了一种叫Aggregator的东西，即聚合函数，用于将一个对象的信息加入到另一个已有对象。这个现在暂不描述。</p><p class="P1">通常我们认为Projector比Aggregator更好书写。</p><p class="P1">IProjectorToProjectorRangeTranslator，就是用来将一个Projector的值域类型变换到另一个类型，也就是：</p><p class="P1">IProjectorToProjectorRangeTranslator(D, M, R): Projector(D, M) -&gt; Projector(D, R)</p><p class="P1">由于.Net不支持返回泛型λ表达式，不能做泛型参数偏特化，因此将本来的三个泛型参数(D, M, R)分成两组(R, M)和(D)，(R, M)定义为接口参数，(D)定义成函数类型参数。</p><p class="P1">这样我们可以先对(R, M)进行特化，再对(D)进行特化，使得高阶函数的实现与定义域类型D无关。</p><p class="P1">同样，IProjectorToProjectorDomainTranslator用于将一个Projector的定义域类型变换到另一个类型。</p><p class="P1"> </p><p class="P1">在ByteArrayCodec中：</p><p class="P1">TranslateProjectorToProjectorRange用于将Projector(D, String)转化为Projector(D, Byte())，内部做了String到Byte()的转换，使用正则表达式实现；</p><p class="P2"><span class="T2">TranslateProjectorToProjectorDomain用于将Projector(Byte(), R)转化为Projector(String, R)，内部做了Byte()到String的转换，使用Byte.ToString(</span><span class="T4">"X2"</span><span class="T2">)来完成。</span></p><p class="P1"> </p><p class="P1">下一步，我们需要变更数据模型，但需要保持对已有用户数据的兼容。</p><p class="P1">这个时候，我们仍然通过对象替代来解决。</p><p class="P1"> </p><p class="P1">首先变更数据模型，将DataEntry增加一个Attribute字段，原DataEntry更名保留：</p><p class="P1"> </p><p class="P3">'版本1的DataEntry</p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">DataEntryVersion1</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Name </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Data </span><span class="T1">As</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">()</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"> </p><p class="P3">'当前版本(版本2)的DataEntry</p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">DataEntry</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Name </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Data </span><span class="T1">As</span><span class="T2"> </span><span class="T1">Byte</span><span class="T2">()</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> Attribute </span><span class="T1">As</span><span class="T2"> </span><span class="T1">String</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"> </p><p class="P1">增加一个对象替代器：</p><p class="P3">'用于适配DataEntry的版本1和版本2</p><p class="P2"><span class="T1">Public</span><span class="T2"> </span><span class="T1">Class</span><span class="T2"> </span><span class="T3">DataEntryVersion1To2Translator</span></p><p class="P2"><span class="T2">    </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorRangeTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2">, </span><span class="T3">DataEntryVersion1</span><span class="T2">) </span><span class="T6">'Reader</span></p><p class="P2"><span class="T2">    </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorDomainTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2">, </span><span class="T3">DataEntryVersion1</span><span class="T2">) </span><span class="T6">'Writer</span></p><p class="P1"> </p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">Function</span><span class="T2"> TranslateProjectorToProjectorRange(</span><span class="T1">Of</span><span class="T2"> D)(</span><span class="T1">ByVal</span><span class="T2"> Projector </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">D</span><span class="T2">, </span><span class="T3">DataEntryVersion1</span><span class="T2">)) </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">D</span><span class="T2">, </span><span class="T3">DataEntry</span><span class="T2">) </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorRangeTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2">, </span><span class="T3">DataEntryVersion1</span><span class="T2">).TranslateProjectorToProjectorRange</span></p><p class="P2"><span class="T2">        </span><span class="T1">Return</span><span class="T2"> </span><span class="T1">Function</span><span class="T2">(DomainValue)</span></p><p class="P2"><span class="T2">                   </span><span class="T1">Dim</span><span class="T2"> v1 = Projector(DomainValue)</span></p><p class="P2"><span class="T2">                   </span><span class="T1">Return</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2"> </span><span class="T1">With</span><span class="T2"> {.Name = v1.Name, .Data = v1.Data, .Attribute = </span><span class="T4">"Version1's attribute"</span><span class="T2">}</span></p><p class="P2"><span class="T2">               </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Function</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Function</span></p><p class="P2"><span class="T2">    </span><span class="T1">Public</span><span class="T2"> </span><span class="T1">Function</span><span class="T2"> TranslateProjectorToProjectorDomain(</span><span class="T1">Of</span><span class="T2"> R)(</span><span class="T1">ByVal</span><span class="T2"> Projector </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataEntryVersion1</span><span class="T2">, </span><span class="T3">R</span><span class="T2">)) </span><span class="T1">As</span><span class="T2"> </span><span class="T3">Func</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2">, </span><span class="T3">R</span><span class="T2">) </span><span class="T1">Implements</span><span class="T2"> </span><span class="T3">IProjectorToProjectorDomainTranslator</span><span class="T2">(</span><span class="T1">Of</span><span class="T2"> </span><span class="T3">DataEntry</span><span class="T2">, </span><span class="T3">DataEntryVersion1</span><span class="T2">).TranslateProjectorToProjectorDomain</span></p><p class="P2"><span class="T2">        </span><span class="T1">Return</span><span class="T2"> </span><span class="T1">Function</span><span class="T2">(v2)</span></p><p class="P2"><span class="T2">                   </span><span class="T1">Dim</span><span class="T2"> v1 = </span><span class="T1">New</span><span class="T2"> </span><span class="T3">DataEntryVersion1</span><span class="T2"> </span><span class="T1">With</span><span class="T2"> {.Name = v2.Name, .Data = v2.Data}</span></p><p class="P2"><span class="T2">                   </span><span class="T1">Return</span><span class="T2"> Projector(v1)</span></p><p class="P2"><span class="T2">               </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Function</span></p><p class="P2"><span class="T2">    </span><span class="T1">End</span><span class="T2"> </span><span class="T1">Function</span></p><p class="P2"><span class="T1">End</span><span class="T2"> </span><span class="T1">Class</span></p><p class="P1"> </p><p class="P1">然后声明两个版本的序列化器，版本1不放入DataEntryVersion1To2Translator，版本2放入DataEntryVersion1To2Translator。</p><p class="P1">为了在文档中加入版本标志，我们可以使用XML元素的Attribute，在写入后增加标记，如：</p><p class="P1"> </p><p class="P2"><span class="T1">Dim</span><span class="T2"> Element = SerializerVersion2.Write(Obj)</span></p><p class="P2"><span class="T2">Element</span><span class="T7">.@&lt;</span><span class="T2">SchemaType</span><span class="T7">&gt;</span><span class="T2"> = </span><span class="T4">"MyDataFormat"</span></p><p class="P2"><span class="T2">Element</span><span class="T7">.@&lt;</span><span class="T2">Version</span><span class="T7">&gt;</span><span class="T2"> = 2</span></p><p class="P1"> </p><p class="P1">在读取的时候，首先读取XElement：</p><p class="P1"> </p><p class="P2"><span class="T1">Dim</span><span class="T2"> SchemaType = Element</span><span class="T7">.@&lt;</span><span class="T2">SchemaType</span><span class="T7">&gt;</span></p><p class="P2"><span class="T1">If</span><span class="T2"> SchemaType &lt;&gt; </span><span class="T4">"MyDataFormat"</span><span class="T2"> </span><span class="T1">Then</span><span class="T2"> </span><span class="T1">Throw</span><span class="T2"> </span><span class="T1">New</span><span class="T2"> </span><span class="T3">InvalidDataException</span><span class="T2">(</span><span class="T4">"数据不是MYDF格式数据"</span><span class="T2">)</span></p><p class="P2"><span class="T1">Dim</span><span class="T2"> Version = </span><span class="T1">Integer</span><span class="T2">.Parse(Element</span><span class="T7">.@&lt;</span><span class="T2">Version</span><span class="T7">&gt;</span><span class="T2">)</span></p><p class="P1"> </p><p class="P1">再通过版本号来选择序列化器进行反序列化。</p><p class="P1"> </p><p class="P2"><span class="T1">&lt;?</span><span class="T4">xml</span><span class="T1"> </span><span class="T5">version</span><span class="T1">=</span><span class="T2">"</span><span class="T1">1.0</span><span class="T2">"</span><span class="T1"> </span><span class="T5">encoding</span><span class="T1">=</span><span class="T2">"</span><span class="T1">gb2312</span><span class="T2">"</span><span class="T1">?&gt;</span></p><p class="P2"><span class="T1">&lt;</span><span class="T4">DataObject</span><span class="T1"> </span><span class="T5">SchemaType</span><span class="T1">=</span><span class="T2">"</span><span class="T1">MyDataFormat</span><span class="T2">"</span><span class="T1"> </span><span class="T5">Version</span><span class="T1">=</span><span class="T2">"</span><span class="T1">2</span><span class="T2">"</span><span class="T1">&gt;</span></p><p class="P1"> </p><p class="P1">这样生成的第二个版本的XML文件就会具有版本号，同时程序可以对各个版本的文件进行兼容。</p><p class="P1">不会出现手写代码时，由于要兼容，出现多套数据模型或者难以修改数据模型的问题。</p><p class="P1">详细的代码，以及二进制序列化的示例请参见附件，有VB和C#两个版本的示例代码，和一个简化的库。</p><p class="P1">简化的库是因为这两个序列化器均是作为萤火虫汉化框架(http://www.cnblogs.com/Rex/archive/2008/11/08/1329759.html)的一部分来开发的。</p><p class="P1"> </p><p class="P1">关于内部实现，主要是通过System.Linq.Expression来进行的，生成的表达式可以被垃圾回收。</p><p class="P1">实现我将在下篇中描述。</p><p class="P1"> </p><p class="P1">所有的示例代码均按Public Domain授权，所有的库代码均按BSD协议授权。如果需要在GPL程序中使用，请与我单独联系授权。</p><p class="P1"> </p><p class="P1">最后携带一点私货，为了解耦我们不要拘泥于面向对象。</p><p class="P1"> </p></body></html>